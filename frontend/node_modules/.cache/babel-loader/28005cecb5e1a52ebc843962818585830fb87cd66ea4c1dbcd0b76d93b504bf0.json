{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useMemo, useRef, useState } from \"react\";\nimport { completeTraining } from \"../../../shared/api/trainApi\";\nimport { useSelector } from \"react-redux\";\nimport { selectAllModuleCards } from \"../../../entities/moduleCard\";\nexport function useTraining(cards, type, modules) {\n  _s();\n  const [index, setIndex] = useState(0);\n  const [results, setResults] = useState({});\n  const [helper, setHelper] = useState(false);\n  const [isFinish, setIsFinish] = useState(false);\n  const [finishResults, setFinishResults] = useState();\n  const startTime = useRef(Date.now());\n  const currentCard = cards[index];\n  const recordAnswer = (cardId, correct) => {\n    setResults(prev => ({\n      ...prev,\n      [cardId]: correct\n    }));\n  };\n  const nextCard = (cardId, correct) => {\n    const newResults = cardId !== undefined && correct !== undefined ? {\n      ...results,\n      [cardId]: correct\n    } : results;\n    if (index < cards.length - 1) {\n      setResults(newResults);\n      setIndex(prev => prev + 1);\n    } else {\n      finish(newResults);\n    }\n  };\n  const calcLevelChange = card => {\n    const correct = results[card.id];\n    if (correct === undefined) return card.level;\n    return correct ? Math.min(card.level + 1, 3) : Math.max(card.level - 1, 0);\n  };\n  const moduleCards = useSelector(selectAllModuleCards);\n  const cardToModule = useMemo(() => {\n    const map = new Map();\n    moduleCards.forEach(mc => {\n      map.set(mc.cardId, mc.moduleId);\n    });\n    return map;\n  }, [moduleCards]);\n  const finish = finalResults => {\n    const duration = Math.floor((Date.now() - startTime.current) / 1000);\n    const resultsToUse = finalResults !== null && finalResults !== void 0 ? finalResults : results;\n    const cardsByModule = {};\n    Object.entries(resultsToUse).forEach(([cardIdStr, correct]) => {\n      const cardId = Number(cardIdStr);\n      const moduleId = cardToModule.get(cardId);\n      if (!moduleId) return;\n      if (!cardsByModule[moduleId]) {\n        cardsByModule[moduleId] = [];\n      }\n      cardsByModule[moduleId].push({\n        cardId,\n        correct\n      });\n    });\n    Object.entries(cardsByModule).forEach(([moduleId, cards]) => {\n      completeTraining({\n        type,\n        modules: [Number(moduleId)],\n        cards,\n        duration\n      });\n    });\n    setIsFinish(true);\n  };\n  return {\n    cards,\n    currentCard,\n    index,\n    nextCard,\n    recordAnswer,\n    finish,\n    results,\n    calcLevelChange,\n    helper,\n    setHelper,\n    isFinish,\n    finishResults\n  };\n}\n_s(useTraining, \"DVKvA4SYrBaRrbzLgkdmpEST7Zs=\", false, function () {\n  return [useSelector];\n});","map":{"version":3,"names":["useMemo","useRef","useState","completeTraining","useSelector","selectAllModuleCards","useTraining","cards","type","modules","_s","index","setIndex","results","setResults","helper","setHelper","isFinish","setIsFinish","finishResults","setFinishResults","startTime","Date","now","currentCard","recordAnswer","cardId","correct","prev","nextCard","newResults","undefined","length","finish","calcLevelChange","card","id","level","Math","min","max","moduleCards","cardToModule","map","Map","forEach","mc","set","moduleId","finalResults","duration","floor","current","resultsToUse","cardsByModule","Object","entries","cardIdStr","Number","get","push"],"sources":["D:/base/GitHub/MemoryCard/frontend/src/features/training/model/useTrainingLogic.ts"],"sourcesContent":["import {useEffect, useMemo, useRef, useState} from \"react\";\r\nimport {completeTraining} from \"../../../shared/api/trainApi\";\r\nimport {useSelector} from \"react-redux\";\r\nimport {Card} from \"../../../entities/card\";\r\nimport {selectAllModuleCards} from \"../../../entities/moduleCard\";\r\n\r\nexport interface TrainingResult {\r\n    [cardId: number]: boolean;\r\n}\r\n\r\nexport interface TrainingPayload {\r\n    type: string;\r\n    modules: number[];\r\n    cards: { cardId: number; correct: boolean }[];\r\n    duration: number;\r\n}\r\n\r\nexport function useTraining(cards: Card[], type: string, modules: number[]) {\r\n    const [index, setIndex] = useState(0);\r\n    const [results, setResults] = useState<TrainingResult>({});\r\n    const [helper, setHelper] = useState(false);\r\n    const [isFinish, setIsFinish] = useState(false);\r\n    const [finishResults, setFinishResults] = useState<TrainingPayload>();\r\n\r\n    const startTime = useRef(Date.now());\r\n\r\n    const currentCard = cards[index];\r\n\r\n    const recordAnswer = (cardId: number, correct: boolean): void => {\r\n        setResults((prev) => ({...prev, [cardId]: correct}));\r\n    };\r\n\r\n    const nextCard = (cardId?: number, correct?: boolean) => {\r\n        const newResults = cardId !== undefined && correct !== undefined\r\n            ? { ...results, [cardId]: correct }\r\n            : results;\r\n\r\n        if (index < cards.length - 1) {\r\n            setResults(newResults);\r\n            setIndex(prev => prev + 1);\r\n        } else {\r\n            finish(newResults);\r\n        }\r\n    };\r\n\r\n\r\n    const calcLevelChange = (card: Card): number => {\r\n        const correct = results[card.id];\r\n        if (correct === undefined) return card.level;\r\n        return correct\r\n            ? Math.min(card.level + 1, 3)\r\n            : Math.max(card.level - 1, 0);\r\n    };\r\n\r\n    const moduleCards = useSelector(selectAllModuleCards);\r\n\r\n    const cardToModule = useMemo(() => {\r\n        const map = new Map<number, number>();\r\n\r\n        moduleCards.forEach(mc => {\r\n            map.set(mc.cardId, mc.moduleId);\r\n        });\r\n\r\n        return map;\r\n    }, [moduleCards]);\r\n\r\n\r\n    const finish = (finalResults?: TrainingResult) => {\r\n        const duration = Math.floor((Date.now() - startTime.current) / 1000);\r\n        const resultsToUse = finalResults ?? results;\r\n\r\n        const cardsByModule: Record<number, { cardId: number; correct: boolean }[]> = {};\r\n\r\n        Object.entries(resultsToUse).forEach(([cardIdStr, correct]) => {\r\n            const cardId = Number(cardIdStr);\r\n            const moduleId = cardToModule.get(cardId);\r\n\r\n            if (!moduleId) return;\r\n\r\n            if (!cardsByModule[moduleId]) {\r\n                cardsByModule[moduleId] = [];\r\n            }\r\n\r\n            cardsByModule[moduleId].push({\r\n                cardId,\r\n                correct,\r\n            });\r\n        });\r\n\r\n        Object.entries(cardsByModule).forEach(([moduleId, cards]) => {\r\n            completeTraining({\r\n                type,\r\n                modules: [Number(moduleId)],\r\n                cards,\r\n                duration,\r\n            });\r\n        });\r\n\r\n        setIsFinish(true);\r\n    };\r\n\r\n    return {\r\n        cards,\r\n        currentCard,\r\n        index,\r\n        nextCard,\r\n        recordAnswer,\r\n        finish,\r\n        results,\r\n        calcLevelChange,\r\n        helper,\r\n        setHelper,\r\n        isFinish,\r\n        finishResults,\r\n    };\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}