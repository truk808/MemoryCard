{"ast":null,"code":"import { createSlice } from '@reduxjs/toolkit';\n\n/**\r\n * This is the data that's coming through main chart `data` prop\r\n * Recharts is very flexible in what it accepts so the type is very flexible too.\r\n * This will typically be an object, and various components will provide various `dataKey`\r\n * that dictates how to pull data from that object.\r\n *\r\n * TL;DR: before dataKey\r\n */\n\n/**\r\n * So this is the same unknown type as ChartData but this is after the dataKey has been applied.\r\n * We still don't know what the type is - that depends on what exactly it was before the dataKey application,\r\n * and the dataKey can return whatever anyway - but let's keep it separate as a form of documentation.\r\n *\r\n * TL;DR: ChartData after dataKey.\r\n */\n\nexport var initialChartDataState = {\n  chartData: undefined,\n  computedData: undefined,\n  dataStartIndex: 0,\n  dataEndIndex: 0\n};\nvar chartDataSlice = createSlice({\n  name: 'chartData',\n  initialState: initialChartDataState,\n  reducers: {\n    setChartData(state, action) {\n      state.chartData = action.payload;\n      if (action.payload == null) {\n        state.dataStartIndex = 0;\n        state.dataEndIndex = 0;\n        return;\n      }\n      if (action.payload.length > 0 && state.dataEndIndex !== action.payload.length - 1) {\n        state.dataEndIndex = action.payload.length - 1;\n      }\n    },\n    setComputedData(state, action) {\n      state.computedData = action.payload;\n    },\n    setDataStartEndIndexes(state, action) {\n      var {\n        startIndex,\n        endIndex\n      } = action.payload;\n      if (startIndex != null) {\n        state.dataStartIndex = startIndex;\n      }\n      if (endIndex != null) {\n        state.dataEndIndex = endIndex;\n      }\n    }\n  }\n});\nexport var {\n  setChartData,\n  setDataStartEndIndexes,\n  setComputedData\n} = chartDataSlice.actions;\nexport var chartDataReducer = chartDataSlice.reducer;","map":{"version":3,"names":["createSlice","initialChartDataState","chartData","undefined","computedData","dataStartIndex","dataEndIndex","chartDataSlice","name","initialState","reducers","setChartData","state","action","payload","length","setComputedData","setDataStartEndIndexes","startIndex","endIndex","actions","chartDataReducer","reducer"],"sources":["D:/base/GitHub/MemoryCard/frontend/node_modules/recharts/es6/state/chartDataSlice.js"],"sourcesContent":["import { createSlice } from '@reduxjs/toolkit';\r\n\r\n/**\r\n * This is the data that's coming through main chart `data` prop\r\n * Recharts is very flexible in what it accepts so the type is very flexible too.\r\n * This will typically be an object, and various components will provide various `dataKey`\r\n * that dictates how to pull data from that object.\r\n *\r\n * TL;DR: before dataKey\r\n */\r\n\r\n/**\r\n * So this is the same unknown type as ChartData but this is after the dataKey has been applied.\r\n * We still don't know what the type is - that depends on what exactly it was before the dataKey application,\r\n * and the dataKey can return whatever anyway - but let's keep it separate as a form of documentation.\r\n *\r\n * TL;DR: ChartData after dataKey.\r\n */\r\n\r\nexport var initialChartDataState = {\r\n  chartData: undefined,\r\n  computedData: undefined,\r\n  dataStartIndex: 0,\r\n  dataEndIndex: 0\r\n};\r\nvar chartDataSlice = createSlice({\r\n  name: 'chartData',\r\n  initialState: initialChartDataState,\r\n  reducers: {\r\n    setChartData(state, action) {\r\n      state.chartData = action.payload;\r\n      if (action.payload == null) {\r\n        state.dataStartIndex = 0;\r\n        state.dataEndIndex = 0;\r\n        return;\r\n      }\r\n      if (action.payload.length > 0 && state.dataEndIndex !== action.payload.length - 1) {\r\n        state.dataEndIndex = action.payload.length - 1;\r\n      }\r\n    },\r\n    setComputedData(state, action) {\r\n      state.computedData = action.payload;\r\n    },\r\n    setDataStartEndIndexes(state, action) {\r\n      var {\r\n        startIndex,\r\n        endIndex\r\n      } = action.payload;\r\n      if (startIndex != null) {\r\n        state.dataStartIndex = startIndex;\r\n      }\r\n      if (endIndex != null) {\r\n        state.dataEndIndex = endIndex;\r\n      }\r\n    }\r\n  }\r\n});\r\nexport var {\r\n  setChartData,\r\n  setDataStartEndIndexes,\r\n  setComputedData\r\n} = chartDataSlice.actions;\r\nexport var chartDataReducer = chartDataSlice.reducer;"],"mappings":"AAAA,SAASA,WAAW,QAAQ,kBAAkB;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,IAAIC,qBAAqB,GAAG;EACjCC,SAAS,EAAEC,SAAS;EACpBC,YAAY,EAAED,SAAS;EACvBE,cAAc,EAAE,CAAC;EACjBC,YAAY,EAAE;AAChB,CAAC;AACD,IAAIC,cAAc,GAAGP,WAAW,CAAC;EAC/BQ,IAAI,EAAE,WAAW;EACjBC,YAAY,EAAER,qBAAqB;EACnCS,QAAQ,EAAE;IACRC,YAAYA,CAACC,KAAK,EAAEC,MAAM,EAAE;MAC1BD,KAAK,CAACV,SAAS,GAAGW,MAAM,CAACC,OAAO;MAChC,IAAID,MAAM,CAACC,OAAO,IAAI,IAAI,EAAE;QAC1BF,KAAK,CAACP,cAAc,GAAG,CAAC;QACxBO,KAAK,CAACN,YAAY,GAAG,CAAC;QACtB;MACF;MACA,IAAIO,MAAM,CAACC,OAAO,CAACC,MAAM,GAAG,CAAC,IAAIH,KAAK,CAACN,YAAY,KAAKO,MAAM,CAACC,OAAO,CAACC,MAAM,GAAG,CAAC,EAAE;QACjFH,KAAK,CAACN,YAAY,GAAGO,MAAM,CAACC,OAAO,CAACC,MAAM,GAAG,CAAC;MAChD;IACF,CAAC;IACDC,eAAeA,CAACJ,KAAK,EAAEC,MAAM,EAAE;MAC7BD,KAAK,CAACR,YAAY,GAAGS,MAAM,CAACC,OAAO;IACrC,CAAC;IACDG,sBAAsBA,CAACL,KAAK,EAAEC,MAAM,EAAE;MACpC,IAAI;QACFK,UAAU;QACVC;MACF,CAAC,GAAGN,MAAM,CAACC,OAAO;MAClB,IAAII,UAAU,IAAI,IAAI,EAAE;QACtBN,KAAK,CAACP,cAAc,GAAGa,UAAU;MACnC;MACA,IAAIC,QAAQ,IAAI,IAAI,EAAE;QACpBP,KAAK,CAACN,YAAY,GAAGa,QAAQ;MAC/B;IACF;EACF;AACF,CAAC,CAAC;AACF,OAAO,IAAI;EACTR,YAAY;EACZM,sBAAsB;EACtBD;AACF,CAAC,GAAGT,cAAc,CAACa,OAAO;AAC1B,OAAO,IAAIC,gBAAgB,GAAGd,cAAc,CAACe,OAAO","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}