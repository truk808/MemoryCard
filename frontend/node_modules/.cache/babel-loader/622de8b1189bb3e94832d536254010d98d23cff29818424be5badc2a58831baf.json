{"ast":null,"code":"import { isValidElement } from 'react';\nimport { isEventKey } from './excludeEventProps';\n\n/**\r\n * Determines how values are stacked:\r\n *\r\n * - `none` is the default, it adds values on top of each other. No smarts. Negative values will overlap.\r\n * - `expand` make it so that the values always add up to 1 - so the chart will look like a rectangle.\r\n * - `wiggle` and `silhouette` tries to keep the chart centered.\r\n * - `sign` stacks positive values above zero and negative values below zero. Similar to `none` but handles negatives.\r\n * - `positive` ignores all negative values, and then behaves like \\`none\\`.\r\n *\r\n * Also see https://d3js.org/d3-shape/stack#stack-offsets\r\n * (note that the `diverging` offset in d3 is named `sign` in recharts)\r\n */\n\n/**\r\n * @deprecated use either `CartesianLayout` or `PolarLayout` instead.\r\n * Mixing both charts families leads to ambiguity in the type system.\r\n * These two layouts share very few properties, so it is best to keep them separate.\r\n */\n\n/**\r\n * @deprecated do not use: too many properties, mixing too many concepts, cartesian and polar together, everything optional.\r\n */\n\n//\n// Event Handler Types -- Copied from @types/react/index.d.ts and adapted for Props.\n//\n\n/** The type of easing function to use for animations */\n\n/** Specifies the duration of animation, the unit of this option is ms. */\n\n/**\r\n * This object defines the offset of the chart area and width and height and brush and ... it's a bit too much information all in one.\r\n * We use it internally but let's not expose it to the outside world.\r\n * If you are looking for this information, instead import `ChartOffset` or `PlotArea` from `recharts`.\r\n */\n\n/**\r\n * The domain of axis.\r\n * This is the definition\r\n *\r\n * Numeric domain is always defined by an array of exactly two values, for the min and the max of the axis.\r\n * Categorical domain is defined as array of all possible values.\r\n *\r\n * Can be specified in many ways:\r\n * - array of numbers\r\n * - with special strings like 'dataMin' and 'dataMax'\r\n * - with special string math like 'dataMin - 100'\r\n * - with keyword 'auto'\r\n * - or a function\r\n * - array of functions\r\n * - or a combination of the above\r\n */\n\n/**\r\n * NumberDomain is an evaluated {@link AxisDomain}.\r\n * Unlike {@link AxisDomain}, it has no variety - it's a tuple of two number.\r\n * This is after all the keywords and functions were evaluated and what is left is [min, max].\r\n *\r\n * Know that the min, max values are not guaranteed to be nice numbers - values like -Infinity or NaN are possible.\r\n *\r\n * There are also `category` axes that have different things than numbers in their domain.\r\n */\n\n/** The props definition of base axis */\n\n/** Defines how ticks are placed and whether / how tick collisions are handled.\r\n * 'preserveStart' keeps the left tick on collision and ensures that the first tick is always shown.\r\n * 'preserveEnd' keeps the right tick on collision and ensures that the last tick is always shown.\r\n * 'preserveStartEnd' keeps the left tick on collision and ensures that the first and last ticks always show.\r\n * 'equidistantPreserveStart' selects a number N such that every nTh tick will be shown without collision.\r\n */\n\n/**\r\n * Ticks can be any type when the axis is the type of category.\r\n *\r\n * Ticks must be numbers when the axis is the type of number.\r\n */\n\nexport var adaptEventHandlers = (props, newHandler) => {\n  if (!props || typeof props === 'function' || typeof props === 'boolean') {\n    return null;\n  }\n  var inputProps = props;\n  if (/*#__PURE__*/isValidElement(props)) {\n    inputProps = props.props;\n  }\n  if (typeof inputProps !== 'object' && typeof inputProps !== 'function') {\n    return null;\n  }\n  var out = {};\n  Object.keys(inputProps).forEach(key => {\n    if (isEventKey(key)) {\n      out[key] = newHandler || (e => inputProps[key](inputProps, e));\n    }\n  });\n  return out;\n};\nvar getEventHandlerOfChild = (originalHandler, data, index) => e => {\n  originalHandler(data, index, e);\n  return null;\n};\nexport var adaptEventsOfChild = (props, data, index) => {\n  if (props === null || typeof props !== 'object' && typeof props !== 'function') {\n    return null;\n  }\n  var out = null;\n  Object.keys(props).forEach(key => {\n    var item = props[key];\n    if (isEventKey(key) && typeof item === 'function') {\n      if (!out) out = {};\n      out[key] = getEventHandlerOfChild(item, data, index);\n    }\n  });\n  return out;\n};\n\n/**\r\n * 'axis' means that all graphical items belonging to this axis tick will be highlighted,\r\n * and all will be present in the tooltip.\r\n * Tooltip with 'axis' will display when hovering on the chart background.\r\n *\r\n * 'item' means only the one graphical item being hovered will show in the tooltip.\r\n * Tooltip with 'item' will display when hovering over individual graphical items.\r\n *\r\n * This is calculated internally;\r\n * charts have a `defaultTooltipEventType` and `validateTooltipEventTypes` options.\r\n *\r\n * Users then use <Tooltip shared={true} /> or <Tooltip shared={false} /> to control their preference,\r\n * and charts will then see what is allowed and what is not.\r\n */\n\n/**\r\n * These are the props we are going to pass to an `activeDot` if it is a function or a custom Component\r\n */\n\n/**\r\n * This is the type of `activeDot` prop on:\r\n * - Area\r\n * - Line\r\n * - Radar\r\n */\n\n// TODO we need two different range objects, one for polar and another for cartesian layouts\n\n/**\r\n * Simplified version of the MouseEvent so that we don't have to mock the whole thing in tests.\r\n *\r\n * This is meant to represent the React.MouseEvent\r\n * which is a wrapper on top of https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent\r\n */\n\n/**\r\n * Coordinates relative to the top-left corner of the chart.\r\n * Also include scale which means that a chart that's scaled will return the same coordinates as a chart that's not scaled.\r\n */","map":{"version":3,"names":["isValidElement","isEventKey","adaptEventHandlers","props","newHandler","inputProps","out","Object","keys","forEach","key","e","getEventHandlerOfChild","originalHandler","data","index","adaptEventsOfChild","item"],"sources":["D:/base/GitHub/MemoryCard/frontend/node_modules/recharts/es6/util/types.js"],"sourcesContent":["import { isValidElement } from 'react';\r\nimport { isEventKey } from './excludeEventProps';\r\n\r\n/**\r\n * Determines how values are stacked:\r\n *\r\n * - `none` is the default, it adds values on top of each other. No smarts. Negative values will overlap.\r\n * - `expand` make it so that the values always add up to 1 - so the chart will look like a rectangle.\r\n * - `wiggle` and `silhouette` tries to keep the chart centered.\r\n * - `sign` stacks positive values above zero and negative values below zero. Similar to `none` but handles negatives.\r\n * - `positive` ignores all negative values, and then behaves like \\`none\\`.\r\n *\r\n * Also see https://d3js.org/d3-shape/stack#stack-offsets\r\n * (note that the `diverging` offset in d3 is named `sign` in recharts)\r\n */\r\n\r\n/**\r\n * @deprecated use either `CartesianLayout` or `PolarLayout` instead.\r\n * Mixing both charts families leads to ambiguity in the type system.\r\n * These two layouts share very few properties, so it is best to keep them separate.\r\n */\r\n\r\n/**\r\n * @deprecated do not use: too many properties, mixing too many concepts, cartesian and polar together, everything optional.\r\n */\r\n\r\n//\r\n// Event Handler Types -- Copied from @types/react/index.d.ts and adapted for Props.\r\n//\r\n\r\n/** The type of easing function to use for animations */\r\n\r\n/** Specifies the duration of animation, the unit of this option is ms. */\r\n\r\n/**\r\n * This object defines the offset of the chart area and width and height and brush and ... it's a bit too much information all in one.\r\n * We use it internally but let's not expose it to the outside world.\r\n * If you are looking for this information, instead import `ChartOffset` or `PlotArea` from `recharts`.\r\n */\r\n\r\n/**\r\n * The domain of axis.\r\n * This is the definition\r\n *\r\n * Numeric domain is always defined by an array of exactly two values, for the min and the max of the axis.\r\n * Categorical domain is defined as array of all possible values.\r\n *\r\n * Can be specified in many ways:\r\n * - array of numbers\r\n * - with special strings like 'dataMin' and 'dataMax'\r\n * - with special string math like 'dataMin - 100'\r\n * - with keyword 'auto'\r\n * - or a function\r\n * - array of functions\r\n * - or a combination of the above\r\n */\r\n\r\n/**\r\n * NumberDomain is an evaluated {@link AxisDomain}.\r\n * Unlike {@link AxisDomain}, it has no variety - it's a tuple of two number.\r\n * This is after all the keywords and functions were evaluated and what is left is [min, max].\r\n *\r\n * Know that the min, max values are not guaranteed to be nice numbers - values like -Infinity or NaN are possible.\r\n *\r\n * There are also `category` axes that have different things than numbers in their domain.\r\n */\r\n\r\n/** The props definition of base axis */\r\n\r\n/** Defines how ticks are placed and whether / how tick collisions are handled.\r\n * 'preserveStart' keeps the left tick on collision and ensures that the first tick is always shown.\r\n * 'preserveEnd' keeps the right tick on collision and ensures that the last tick is always shown.\r\n * 'preserveStartEnd' keeps the left tick on collision and ensures that the first and last ticks always show.\r\n * 'equidistantPreserveStart' selects a number N such that every nTh tick will be shown without collision.\r\n */\r\n\r\n/**\r\n * Ticks can be any type when the axis is the type of category.\r\n *\r\n * Ticks must be numbers when the axis is the type of number.\r\n */\r\n\r\nexport var adaptEventHandlers = (props, newHandler) => {\r\n  if (!props || typeof props === 'function' || typeof props === 'boolean') {\r\n    return null;\r\n  }\r\n  var inputProps = props;\r\n  if (/*#__PURE__*/isValidElement(props)) {\r\n    inputProps = props.props;\r\n  }\r\n  if (typeof inputProps !== 'object' && typeof inputProps !== 'function') {\r\n    return null;\r\n  }\r\n  var out = {};\r\n  Object.keys(inputProps).forEach(key => {\r\n    if (isEventKey(key)) {\r\n      out[key] = newHandler || (e => inputProps[key](inputProps, e));\r\n    }\r\n  });\r\n  return out;\r\n};\r\nvar getEventHandlerOfChild = (originalHandler, data, index) => e => {\r\n  originalHandler(data, index, e);\r\n  return null;\r\n};\r\nexport var adaptEventsOfChild = (props, data, index) => {\r\n  if (props === null || typeof props !== 'object' && typeof props !== 'function') {\r\n    return null;\r\n  }\r\n  var out = null;\r\n  Object.keys(props).forEach(key => {\r\n    var item = props[key];\r\n    if (isEventKey(key) && typeof item === 'function') {\r\n      if (!out) out = {};\r\n      out[key] = getEventHandlerOfChild(item, data, index);\r\n    }\r\n  });\r\n  return out;\r\n};\r\n\r\n/**\r\n * 'axis' means that all graphical items belonging to this axis tick will be highlighted,\r\n * and all will be present in the tooltip.\r\n * Tooltip with 'axis' will display when hovering on the chart background.\r\n *\r\n * 'item' means only the one graphical item being hovered will show in the tooltip.\r\n * Tooltip with 'item' will display when hovering over individual graphical items.\r\n *\r\n * This is calculated internally;\r\n * charts have a `defaultTooltipEventType` and `validateTooltipEventTypes` options.\r\n *\r\n * Users then use <Tooltip shared={true} /> or <Tooltip shared={false} /> to control their preference,\r\n * and charts will then see what is allowed and what is not.\r\n */\r\n\r\n/**\r\n * These are the props we are going to pass to an `activeDot` if it is a function or a custom Component\r\n */\r\n\r\n/**\r\n * This is the type of `activeDot` prop on:\r\n * - Area\r\n * - Line\r\n * - Radar\r\n */\r\n\r\n// TODO we need two different range objects, one for polar and another for cartesian layouts\r\n\r\n/**\r\n * Simplified version of the MouseEvent so that we don't have to mock the whole thing in tests.\r\n *\r\n * This is meant to represent the React.MouseEvent\r\n * which is a wrapper on top of https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent\r\n */\r\n\r\n/**\r\n * Coordinates relative to the top-left corner of the chart.\r\n * Also include scale which means that a chart that's scaled will return the same coordinates as a chart that's not scaled.\r\n */"],"mappings":"AAAA,SAASA,cAAc,QAAQ,OAAO;AACtC,SAASC,UAAU,QAAQ,qBAAqB;;AAEhD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,OAAO,IAAIC,kBAAkB,GAAGA,CAACC,KAAK,EAAEC,UAAU,KAAK;EACrD,IAAI,CAACD,KAAK,IAAI,OAAOA,KAAK,KAAK,UAAU,IAAI,OAAOA,KAAK,KAAK,SAAS,EAAE;IACvE,OAAO,IAAI;EACb;EACA,IAAIE,UAAU,GAAGF,KAAK;EACtB,IAAI,aAAaH,cAAc,CAACG,KAAK,CAAC,EAAE;IACtCE,UAAU,GAAGF,KAAK,CAACA,KAAK;EAC1B;EACA,IAAI,OAAOE,UAAU,KAAK,QAAQ,IAAI,OAAOA,UAAU,KAAK,UAAU,EAAE;IACtE,OAAO,IAAI;EACb;EACA,IAAIC,GAAG,GAAG,CAAC,CAAC;EACZC,MAAM,CAACC,IAAI,CAACH,UAAU,CAAC,CAACI,OAAO,CAACC,GAAG,IAAI;IACrC,IAAIT,UAAU,CAACS,GAAG,CAAC,EAAE;MACnBJ,GAAG,CAACI,GAAG,CAAC,GAAGN,UAAU,KAAKO,CAAC,IAAIN,UAAU,CAACK,GAAG,CAAC,CAACL,UAAU,EAAEM,CAAC,CAAC,CAAC;IAChE;EACF,CAAC,CAAC;EACF,OAAOL,GAAG;AACZ,CAAC;AACD,IAAIM,sBAAsB,GAAGA,CAACC,eAAe,EAAEC,IAAI,EAAEC,KAAK,KAAKJ,CAAC,IAAI;EAClEE,eAAe,CAACC,IAAI,EAAEC,KAAK,EAAEJ,CAAC,CAAC;EAC/B,OAAO,IAAI;AACb,CAAC;AACD,OAAO,IAAIK,kBAAkB,GAAGA,CAACb,KAAK,EAAEW,IAAI,EAAEC,KAAK,KAAK;EACtD,IAAIZ,KAAK,KAAK,IAAI,IAAI,OAAOA,KAAK,KAAK,QAAQ,IAAI,OAAOA,KAAK,KAAK,UAAU,EAAE;IAC9E,OAAO,IAAI;EACb;EACA,IAAIG,GAAG,GAAG,IAAI;EACdC,MAAM,CAACC,IAAI,CAACL,KAAK,CAAC,CAACM,OAAO,CAACC,GAAG,IAAI;IAChC,IAAIO,IAAI,GAAGd,KAAK,CAACO,GAAG,CAAC;IACrB,IAAIT,UAAU,CAACS,GAAG,CAAC,IAAI,OAAOO,IAAI,KAAK,UAAU,EAAE;MACjD,IAAI,CAACX,GAAG,EAAEA,GAAG,GAAG,CAAC,CAAC;MAClBA,GAAG,CAACI,GAAG,CAAC,GAAGE,sBAAsB,CAACK,IAAI,EAAEH,IAAI,EAAEC,KAAK,CAAC;IACtD;EACF,CAAC,CAAC;EACF,OAAOT,GAAG;AACZ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}