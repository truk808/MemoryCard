{"ast":null,"code":"import { useLayoutEffect, useRef } from 'react';\nimport { useAppDispatch } from './hooks';\nimport { addCartesianGraphicalItem, addPolarGraphicalItem, removeCartesianGraphicalItem, removePolarGraphicalItem, replaceCartesianGraphicalItem } from './graphicalItemsSlice';\nexport function SetCartesianGraphicalItem(props) {\n  var dispatch = useAppDispatch();\n  var prevPropsRef = useRef(null);\n  useLayoutEffect(() => {\n    if (prevPropsRef.current === null) {\n      dispatch(addCartesianGraphicalItem(props));\n    } else if (prevPropsRef.current !== props) {\n      dispatch(replaceCartesianGraphicalItem({\n        prev: prevPropsRef.current,\n        next: props\n      }));\n    }\n    prevPropsRef.current = props;\n  }, [dispatch, props]);\n  useLayoutEffect(() => {\n    return () => {\n      if (prevPropsRef.current) {\n        dispatch(removeCartesianGraphicalItem(prevPropsRef.current));\n        /*\r\n         * Here we have to reset the ref to null because in StrictMode, the effect will run twice,\r\n         * but it will keep the same ref value from the first render.\r\n         *\r\n         * In browser, React will clear the ref after the first effect cleanup,\r\n         * so that wouldn't be an issue.\r\n         *\r\n         * In StrictMode, however, the ref is kept,\r\n         * and in the hook above the code checks for `prevPropsRef.current === null`\r\n         * which would be false so it would not dispatch the `addCartesianGraphicalItem` action again.\r\n         *\r\n         * https://github.com/recharts/recharts/issues/6022\r\n         */\n        prevPropsRef.current = null;\n      }\n    };\n  }, [dispatch]);\n  return null;\n}\nexport function SetPolarGraphicalItem(props) {\n  var dispatch = useAppDispatch();\n  useLayoutEffect(() => {\n    dispatch(addPolarGraphicalItem(props));\n    return () => {\n      dispatch(removePolarGraphicalItem(props));\n    };\n  }, [dispatch, props]);\n  return null;\n}","map":{"version":3,"names":["useLayoutEffect","useRef","useAppDispatch","addCartesianGraphicalItem","addPolarGraphicalItem","removeCartesianGraphicalItem","removePolarGraphicalItem","replaceCartesianGraphicalItem","SetCartesianGraphicalItem","props","dispatch","prevPropsRef","current","prev","next","SetPolarGraphicalItem"],"sources":["D:/base/GitHub/MemoryCard/frontend/node_modules/recharts/es6/state/SetGraphicalItem.js"],"sourcesContent":["import { useLayoutEffect, useRef } from 'react';\r\nimport { useAppDispatch } from './hooks';\r\nimport { addCartesianGraphicalItem, addPolarGraphicalItem, removeCartesianGraphicalItem, removePolarGraphicalItem, replaceCartesianGraphicalItem } from './graphicalItemsSlice';\r\nexport function SetCartesianGraphicalItem(props) {\r\n  var dispatch = useAppDispatch();\r\n  var prevPropsRef = useRef(null);\r\n  useLayoutEffect(() => {\r\n    if (prevPropsRef.current === null) {\r\n      dispatch(addCartesianGraphicalItem(props));\r\n    } else if (prevPropsRef.current !== props) {\r\n      dispatch(replaceCartesianGraphicalItem({\r\n        prev: prevPropsRef.current,\r\n        next: props\r\n      }));\r\n    }\r\n    prevPropsRef.current = props;\r\n  }, [dispatch, props]);\r\n  useLayoutEffect(() => {\r\n    return () => {\r\n      if (prevPropsRef.current) {\r\n        dispatch(removeCartesianGraphicalItem(prevPropsRef.current));\r\n        /*\r\n         * Here we have to reset the ref to null because in StrictMode, the effect will run twice,\r\n         * but it will keep the same ref value from the first render.\r\n         *\r\n         * In browser, React will clear the ref after the first effect cleanup,\r\n         * so that wouldn't be an issue.\r\n         *\r\n         * In StrictMode, however, the ref is kept,\r\n         * and in the hook above the code checks for `prevPropsRef.current === null`\r\n         * which would be false so it would not dispatch the `addCartesianGraphicalItem` action again.\r\n         *\r\n         * https://github.com/recharts/recharts/issues/6022\r\n         */\r\n        prevPropsRef.current = null;\r\n      }\r\n    };\r\n  }, [dispatch]);\r\n  return null;\r\n}\r\nexport function SetPolarGraphicalItem(props) {\r\n  var dispatch = useAppDispatch();\r\n  useLayoutEffect(() => {\r\n    dispatch(addPolarGraphicalItem(props));\r\n    return () => {\r\n      dispatch(removePolarGraphicalItem(props));\r\n    };\r\n  }, [dispatch, props]);\r\n  return null;\r\n}"],"mappings":"AAAA,SAASA,eAAe,EAAEC,MAAM,QAAQ,OAAO;AAC/C,SAASC,cAAc,QAAQ,SAAS;AACxC,SAASC,yBAAyB,EAAEC,qBAAqB,EAAEC,4BAA4B,EAAEC,wBAAwB,EAAEC,6BAA6B,QAAQ,uBAAuB;AAC/K,OAAO,SAASC,yBAAyBA,CAACC,KAAK,EAAE;EAC/C,IAAIC,QAAQ,GAAGR,cAAc,CAAC,CAAC;EAC/B,IAAIS,YAAY,GAAGV,MAAM,CAAC,IAAI,CAAC;EAC/BD,eAAe,CAAC,MAAM;IACpB,IAAIW,YAAY,CAACC,OAAO,KAAK,IAAI,EAAE;MACjCF,QAAQ,CAACP,yBAAyB,CAACM,KAAK,CAAC,CAAC;IAC5C,CAAC,MAAM,IAAIE,YAAY,CAACC,OAAO,KAAKH,KAAK,EAAE;MACzCC,QAAQ,CAACH,6BAA6B,CAAC;QACrCM,IAAI,EAAEF,YAAY,CAACC,OAAO;QAC1BE,IAAI,EAAEL;MACR,CAAC,CAAC,CAAC;IACL;IACAE,YAAY,CAACC,OAAO,GAAGH,KAAK;EAC9B,CAAC,EAAE,CAACC,QAAQ,EAAED,KAAK,CAAC,CAAC;EACrBT,eAAe,CAAC,MAAM;IACpB,OAAO,MAAM;MACX,IAAIW,YAAY,CAACC,OAAO,EAAE;QACxBF,QAAQ,CAACL,4BAA4B,CAACM,YAAY,CAACC,OAAO,CAAC,CAAC;QAC5D;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;QACQD,YAAY,CAACC,OAAO,GAAG,IAAI;MAC7B;IACF,CAAC;EACH,CAAC,EAAE,CAACF,QAAQ,CAAC,CAAC;EACd,OAAO,IAAI;AACb;AACA,OAAO,SAASK,qBAAqBA,CAACN,KAAK,EAAE;EAC3C,IAAIC,QAAQ,GAAGR,cAAc,CAAC,CAAC;EAC/BF,eAAe,CAAC,MAAM;IACpBU,QAAQ,CAACN,qBAAqB,CAACK,KAAK,CAAC,CAAC;IACtC,OAAO,MAAM;MACXC,QAAQ,CAACJ,wBAAwB,CAACG,KAAK,CAAC,CAAC;IAC3C,CAAC;EACH,CAAC,EAAE,CAACC,QAAQ,EAAED,KAAK,CAAC,CAAC;EACrB,OAAO,IAAI;AACb","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}